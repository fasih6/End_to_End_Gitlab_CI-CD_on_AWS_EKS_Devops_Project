stages:
  - deploy_to_eks



deploy-to-eks-job:
  stage: deploy_to_eks
  image:
    name: bitnami/kubectl:latest
    entrypoint: [""]        # ðŸ‘ˆ IMPORTANT: disable kubectl as entrypoint
  # needs:
  #   - job: update-k8s-manifests-job
  script:
    # 1) Recreate kubeconfig from GitLab variable (if you're using it)
    - echo "$KUBECONFIG_DATA" | base64 -d > kubeconfig
    - export KUBECONFIG=$PWD/kubeconfig

    # 2) Sanity checks
    - kubectl config current-context || echo "No context set"
    - kubectl get ns
    - kubectl get pods -n prod || echo "no pods in prod yet"

    # 3) Apply your manifests
    - kubectl apply -f k8s-prod/ -n prod
  only:
    - main 






# stages:
#   - install_tools 
#   - security_scan
#   - test
#   - code_quality
#   - docker_build_scan_push
#   - update_manifests
#   - deploy_to_eks

# variables:
#   DOCKER_REGISTRY: "docker.io"
#   DOCKER_IMAGE_BACKEND: "$DOCKER_USERNAME/backend"
#   DOCKER_IMAGE_FRONTEND: "$DOCKER_USERNAME/frontend"

# # ==================== INSTALL TOOLS ====================
# install-tools-job:
#   stage: install_tools
#   script:
#     - sudo apt-get update -y
#     - sudo apt-get install wget apt-transport-https gnupg lsb-release -y
#     - wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | sudo apt-key add -
#     - echo "deb https://aquasecurity.github.io/trivy-repo/deb $(lsb_release -sc) main" | sudo tee /etc/apt/sources.list.d/trivy.list
#     - sudo apt-get update -y
#     - sudo apt-get install trivy -y
#     - sudo apt install gitleaks -y
#   tags:
#     - self-hosted
#   cache:
#     key: tools-cache
#     paths:
#       - /usr/bin/trivy
#       - /usr/bin/gitleaks

# # ==================== SECURITY SCANS (Parallel) ====================
# gitleaks-scan-job:
#   stage: security_scan
#   script:
#     - echo "ðŸ” Scanning for secrets with Gitleaks..."
#     - gitleaks detect --source . -v -r gitleaks-report.json --redact --exit-code 0
#     - |
#       if [ -s gitleaks-report.json ]; then
#         echo "âš ï¸ Secrets detected! Check the artifact report."
#       else
#         echo "âœ… No secrets found."
#       fi
#   needs:
#     - job: install-tools-job
#   allow_failure: true
#   artifacts:
#     when: always
#     expire_in: 30 days
#     paths:
#       - gitleaks-report.json
#     reports:
#       # GitLab can parse this for security dashboard
#       secret_detection: gitleaks-report.json
#   tags:
#     - self-hosted

# trivy-fs-scan-job:
#   stage: security_scan
#   script:
#     - echo "ðŸ” Scanning filesystem for vulnerabilities..."
#     - trivy fs --format json -o trivy-fs-report.json --exit-code 0 .
#     - trivy fs --format table -o trivy-fs-report.html .
#     - |
#       CRITICAL=$(grep -o '"Severity":"CRITICAL"' trivy-fs-report.json | wc -l || echo 0)
#       HIGH=$(grep -o '"Severity":"HIGH"' trivy-fs-report.json | wc -l || echo 0)

#       echo "ðŸ“Š Found $CRITICAL CRITICAL and $HIGH HIGH vulnerabilities"

#       if [ "$CRITICAL" -gt 0 ] || [ "$HIGH" -gt 0 ]; then
#         echo "âš ï¸ Vulnerabilities detected! Review the report."
#       fi
#   needs:
#     - job: install-tools-job
#   allow_failure: true
#   artifacts:
#     when: always
#     expire_in: 30 days
#     paths:
#       - trivy-fs-report.json
#       - trivy-fs-report.html
#   tags:
#     - self-hosted 

# # ==================== TESTS ====================
# unit-test-job:
#   stage: test
#   script:
#     - echo "ðŸ§ª Running unit tests..."
#     - echo "Test cases executed successfully"
#     # Add your actual test commands here:
#     # - npm test
#     # - pytest
#   needs:
#     - job: gitleaks-scan-job
#       artifacts: false
#     - job: trivy-fs-scan-job
#       artifacts: false
#   tags:
#     - self-hosted

# # ==================== CODE QUALITY ====================
# sonarqube-analysis-job:
#   stage: code_quality
#   image: 
#     name: sonarsource/sonar-scanner-cli:11
#   needs:
#     - job: unit-test-job
#   cache:
#     policy: pull-push
#     key: "sonar-cache-${CI_COMMIT_REF_SLUG}"
#     paths:
#       - .sonar/cache
#   script: 
#     - sonar-scanner
#         -Dsonar.sources=.
#         -Dsonar.host.url=${SONAR_HOST_URL}
#         -Dsonar.login=${SONAR_TOKEN}
#   allow_failure: true
#   artifacts:
#     when: always
#     expire_in: 7 days
#     paths:
#       - .scannerwork/
#   rules:
#     - if: $CI_PIPELINE_SOURCE == 'merge_request_event'
#     - if: $CI_COMMIT_BRANCH == 'main'


# # ==================== BUILD_SCAN_PUSH IMAGES ====================
# build-scan-push-job:
#   stage: docker_build_scan_push
#   image: docker:27
#   services:
#     - docker:27-dind
#   variables:
#     DOCKER_TLS_CERTDIR: ""
#     DOCKER_HOST: tcp://docker:2375
#     IMAGE_TAG: "${CI_COMMIT_REF_SLUG}-${CI_COMMIT_SHORT_SHA}"
#   needs:
#     - job: sonarqube-analysis-job
#   before_script:
#     - echo "$DOCKER_PASSWORD" | docker login -u "$DOCKER_USERNAME" --password-stdin
#     - apk add --no-cache curl bash
#     - curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh -s -- -b /usr/local/bin
#   script:
#     # ===== BUILD =====
#     - docker build -t "${DOCKER_IMAGE_BACKEND}:${IMAGE_TAG}" ./api
#     - docker build -t "${DOCKER_IMAGE_FRONTEND}:${IMAGE_TAG}" ./client

#     # ===== SCAN =====
#     - trivy image --severity CRITICAL,HIGH --format json -o backend-scan.json "${DOCKER_IMAGE_BACKEND}:${IMAGE_TAG}"
#     - trivy image --severity CRITICAL,HIGH --format json -o frontend-scan.json "${DOCKER_IMAGE_FRONTEND}:${IMAGE_TAG}"

#     # Count and check CRITICAL vulnerabilities
#     - BACKEND_CRITICAL=$(grep -c '"Severity":"CRITICAL"' backend-scan.json || echo 0)
#     - FRONTEND_CRITICAL=$(grep -c '"Severity":"CRITICAL"' frontend-scan.json || echo 0)
#     - |
#       if [ "$BACKEND_CRITICAL" -gt 0 ] || [ "$FRONTEND_CRITICAL" -gt 0 ]; then
#         echo "âŒ Found $BACKEND_CRITICAL backend + $FRONTEND_CRITICAL frontend CRITICAL vulnerabilities"
#         exit 1
#       fi
    
#     # ===== PUSH =====
#     - docker tag "${DOCKER_IMAGE_BACKEND}:${IMAGE_TAG}" "${DOCKER_IMAGE_BACKEND}:latest"
#     - docker tag "${DOCKER_IMAGE_FRONTEND}:${IMAGE_TAG}" "${DOCKER_IMAGE_FRONTEND}:latest"

#     - docker push "${DOCKER_IMAGE_BACKEND}:${IMAGE_TAG}"
#     - docker push "${DOCKER_IMAGE_BACKEND}:latest"
#     - docker push "${DOCKER_IMAGE_FRONTEND}:${IMAGE_TAG}"
#     - docker push "${DOCKER_IMAGE_FRONTEND}:latest"

#   artifacts:
#     when: always
#     paths:
#       - backend-scan.json
#       - frontend-scan.json
#   only:
#     - main 

# # ==================== UPDATE K8S MANIFESTS ====================
# update-k8s-manifests-job:
#   stage: update_manifests
#   image: alpine:latest
#   variables:
#     IMAGE_TAG: "${CI_COMMIT_REF_SLUG}-${CI_COMMIT_SHORT_SHA}"
#   needs:
#     - job: build-scan-push-job
#   before_script:
#     - apk add --no-cache git
#   script:
#     - echo "Updating Kubernetes manifests with image tag ${IMAGE_TAG}"
    
#     # Update backend image tag 
#     - |
#       sed -i "s|image:.*${DOCKER_IMAGE_BACKEND}:.*|image: ${DOCKER_IMAGE_BACKEND}:${IMAGE_TAG}|" k8s-prod/backend.yaml
    
#     # Update frontend image tag 
#     - |
#       sed -i "s|image:.*${DOCKER_IMAGE_FRONTEND}:.*|image: ${DOCKER_IMAGE_FRONTEND}:${IMAGE_TAG}|" k8s-prod/frontend.yaml
    
#     # Verify changes
#     - echo "âœ… Manifest updates:"
#     - grep "image:" k8s-prod/backend.yaml
#     - grep "image:" k8s-prod/frontend.yaml
    
#     # Configure Git
#     - git config user.email "gitlab-ci@pipeline.com"
#     - git config user.name "GitLab CI/CD"
    
#     # Checkout the actual branch (not detached HEAD)
#     - git checkout ${CI_COMMIT_REF_NAME}
    
#     # Authenticate with GitLab using Personal Access Token
#     - git remote set-url origin "https://oauth2:${GITLAB_PUSH_TOKEN}@${CI_SERVER_HOST}/${CI_PROJECT_PATH}.git"
    
#     # Commit and push
#     - git add k8s-prod/backend.yaml k8s-prod/frontend.yaml
#     - |
#       git diff --cached --quiet || \
#       git commit -m "ðŸš€ Deploy ${IMAGE_TAG} to production [skip ci]
      
#       - Backend: ${DOCKER_IMAGE_BACKEND}:${IMAGE_TAG}
#       - Frontend: ${DOCKER_IMAGE_FRONTEND}:${IMAGE_TAG}
#       - Commit: ${CI_COMMIT_SHORT_SHA}
#       - Pipeline: ${CI_PIPELINE_URL}"
    
#     - git push origin ${CI_COMMIT_REF_NAME}
    
#     - echo "âœ… Manifests updated and pushed to repository"
#   only:
#     - main

#     # ==================== DEPLOY TO EKS ====================
# deploy-to-eks-job:
#   stage: deploy_to_eks
#   image:
#     name: bitnami/kubectl:latest
#     entrypoint: [""]        # ðŸ‘ˆ IMPORTANT: disable kubectl as entrypoint
#   needs:
#     - job: update-k8s-manifests-job
#   script:
#     # 1) Recreate kubeconfig from GitLab variable (if you're using it)
#     - echo "$KUBECONFIG_DATA" | base64 -d > kubeconfig
#     - export KUBECONFIG=$PWD/kubeconfig

#     # 2) Sanity checks
#     - kubectl config current-context || echo "No context set"
#     - kubectl get ns
#     - kubectl get pods -n prod || echo "no pods in prod yet"

#     # 3) Apply your manifests
#     - kubectl apply -f k8s-prod/ -n prod
#   only:
#     - main 